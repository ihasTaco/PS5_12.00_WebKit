/*
 * Copyright (C) 2021 Sony Interactive Entertainment Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "PlayStationWebView.h"

#include "APIPageConfiguration.h"
#include "APIViewClient.h"
#include "APIViewPopupMenuClient.h"
#include "DrawingAreaProxy.h"
#include "DrawingAreaProxyCoordinatedGraphics.h"
#include "WebPageGroup.h"
#include "WebPopupMenuProxyPlayStation.h"
#include "WebProcessPool.h"

using namespace WebCore;

namespace WebKit {

RefPtr<PlayStationWebView> PlayStationWebView::create(const API::PageConfiguration& configuration)
{
    return adoptRef(*new PlayStationWebView(configuration));
}

PlayStationWebView::PlayStationWebView(const API::PageConfiguration& conf)
    : m_pageClient(makeUnique<PageClientImpl>(*this))
    , m_viewStateFlags { WebCore::ActivityState::WindowIsActive, WebCore::ActivityState::IsFocused, WebCore::ActivityState::IsVisible, WebCore::ActivityState::IsInWindow }
{
    auto configuration = conf.copy();
    auto* preferences = configuration->preferences();
    if (!preferences && configuration->pageGroup()) {
        preferences = &configuration->pageGroup()->preferences();
        configuration->setPreferences(preferences);
    }

#if ENABLE(REMOTE_INSPECTOR)
    if (auto* relatedPage = configuration->relatedPage())
        configuration->setControlledByAutomation(relatedPage->isControlledByAutomation());
#endif

    // Force to use accelerated compositing in every webpages when it's enabled
    if (preferences)
        preferences->setForceCompositingMode(true);

    auto* pool = configuration->processPool();
    m_page = pool->createWebPage(*m_pageClient, WTFMove(configuration));

    m_page->initializeWebPage();
}

PlayStationWebView::~PlayStationWebView()
{
}

void PlayStationWebView::setClient(std::unique_ptr<API::ViewClient>&& client)
{
    if (!client)
        m_client = makeUnique<API::ViewClient>();
    else
        m_client = WTFMove(client);
}

void PlayStationWebView::setPopupMenuClient(std::unique_ptr<API::ViewPopupMenuClient>&& client)
{
    if (!client)
        m_popupMenuClient = makeUnique<API::ViewPopupMenuClient>();
    else
        m_popupMenuClient = WTFMove(client);
}

void PlayStationWebView::setViewSize(WebCore::IntSize viewSize)
{
    m_viewSize = viewSize;
    if (auto drawingArea = m_page->drawingArea())
        drawingArea->setSize(viewSize);
}

void PlayStationWebView::setViewState(OptionSet<WebCore::ActivityState> flags)
{
    auto changedFlags = m_viewStateFlags ^ flags;
    m_viewStateFlags = flags;

    if (changedFlags)
        m_page->activityStateDidChange(changedFlags);
}

void PlayStationWebView::setViewNeedsDisplay(const WebCore::Region& region)
{
    if (m_client)
        m_client->setViewNeedsDisplay(*this, region);
}

#if ENABLE(CURSOR_NAVIGATION)
void PlayStationWebView::setCursorPosition(const WebCore::IntPoint& cursorPosition)
{
    if (m_client)
        m_client->setCursorPosition(*this, cursorPosition);
}
#endif

void PlayStationWebView::doneWithKeyEvent(const NativeWebKeyboardEvent& event, bool wasEventHandled)
{
    if (m_client)
        m_client->doneWithKeyboardEvent(*this, event, wasEventHandled);
}

// LayerTreeContext.contextID is canvas handle generated by WebProcess.
void PlayStationWebView::enterAcceleratedCompositingMode(const LayerTreeContext& context)
{
    if (m_client)
        m_client->enterAcceleratedCompositingMode(*this, context);
}

void PlayStationWebView::exitAcceleratedCompositingMode()
{
    if (m_client)
        m_client->exitAcceleratedCompositingMode(*this);
}

void PlayStationWebView::updateAcceleratedCompositingMode(const LayerTreeContext&)
{

}

int PlayStationWebView::launchOpenGLServerProcess()
{
    if (m_client)
        return m_client->launchOpenGLServerProcess(*this);
    return 0;
}

#if ENABLE(FULLSCREEN_API)
void PlayStationWebView::willEnterFullScreen()
{
    m_isFullScreen = true;
    m_page->fullScreenManager()->willEnterFullScreen();
}

void PlayStationWebView::didEnterFullScreen()
{
    m_page->fullScreenManager()->didEnterFullScreen();
}

void PlayStationWebView::willExitFullScreen()
{
    m_page->fullScreenManager()->willExitFullScreen();
}

void PlayStationWebView::didExitFullScreen()
{
    m_page->fullScreenManager()->didExitFullScreen();
    m_isFullScreen = false;
}

void PlayStationWebView::requestExitFullScreen()
{
    if (isFullScreen())
        m_page->fullScreenManager()->requestExitFullScreen();
}

void PlayStationWebView::closeFullScreenManager()
{
    if (m_client && isFullScreen())
        m_client->closeFullScreen(*this);
    m_isFullScreen = false;
}

bool PlayStationWebView::isFullScreen()
{
    return m_isFullScreen;
}

void PlayStationWebView::enterFullScreen()
{
    if (m_client && !isFullScreen())
        m_client->enterFullScreen(*this);
}

void PlayStationWebView::exitFullScreen()
{
    if (m_client && isFullScreen())
        m_client->exitFullScreen(*this);
}

void PlayStationWebView::beganEnterFullScreen(const WebCore::IntRect& initialFrame, const WebCore::IntRect& finalFrame)
{
    if (m_client)
        m_client->beganEnterFullScreen(*this, initialFrame, finalFrame);
}

void PlayStationWebView::beganExitFullScreen(const WebCore::IntRect& initialFrame, const WebCore::IntRect& finalFrame)
{
    if (m_client)
        m_client->beganExitFullScreen(*this, initialFrame, finalFrame);
}
#endif

void PlayStationWebView::setCursor(const WebCore::Cursor& cursor)
{
    if (m_client)
        m_client->setCursor(*this, cursor);
}

#if ENABLE(ACCESSIBILITY)
void PlayStationWebView::setAccessibilityClient(const WKViewAccessibilityClientBase* client)
{
    m_axClient.initialize(client);
}

void PlayStationWebView::handleAccessibilityNotification(WebAccessibilityObject* axObject, WebCore::AXObjectCache::AXNotification notification)
{
    m_axClient.accessibilityNotification(this, axObject, notification);
}

void PlayStationWebView::handleAccessibilityTextChange(WebAccessibilityObject* axObject, WebCore::AXTextChange textChange, uint32_t offset, const String& text)
{
    m_axClient.accessibilityTextChanged(this, axObject, textChange, offset, text);
}

void PlayStationWebView::handleAccessibilityLoadingEvent(WebAccessibilityObject* axObject, WebCore::AXObjectCache::AXLoadingEvent loadingEvent)
{
    m_axClient.accessibilityLoadingEvent(this, axObject, loadingEvent);
}

void PlayStationWebView::accessibilityRootObject()
{
    return m_page->accessibilityRootObject();
}

void PlayStationWebView::handleAccessibilityRootObject(WebAccessibilityObject* axObject)
{
    m_axClient.handleAccessibilityRootObject(this, axObject);
}

void PlayStationWebView::accessibilityFocusedObject()
{
    m_page->accessibilityFocusedObject();
}

void PlayStationWebView::handleAccessibilityFocusedObject(WebAccessibilityObject* axObject)
{
    m_axClient.handleAccessibilityFocusedObject(this, axObject);
}

void PlayStationWebView::accessibilityHitTest(const WebCore::IntPoint& point)
{
    m_page->accessibilityHitTest(point);
}

void PlayStationWebView::handleAccessibilityHitTest(WebAccessibilityObject* axObject)
{
    m_axClient.handleAccessibilityHitTest(this, axObject);
}
#endif

void PlayStationWebView::showPopupMenu(WebPopupMenuProxyPlayStation* popupMenuProxy, const Vector<WebPopupItem>& items, const WebCore::IntRect& rect, int32_t selectedIndex)
{
    m_popupMenuProxy = popupMenuProxy;
    if (m_popupMenuClient)
        m_popupMenuClient->showPopupMenu(*this, items, rect, selectedIndex);
}

void PlayStationWebView::hidePopupMenu()
{
    if (m_popupMenuClient)
        m_popupMenuClient->hidePopupMenu(*this);
    m_popupMenuProxy = nullptr;
}

void PlayStationWebView::valueChangedForPopupMenu(int selectedIndex)
{
    if (m_popupMenuProxy)
        m_popupMenuProxy->valueChangedForPopupMenu(selectedIndex);
}

void PlayStationWebView::doneWithMouseUpEvent(bool wasEventHandled)
{
    if (m_client)
        m_client->doneWithMouseUpEvent(*this, wasEventHandled);
}

void PlayStationWebView::didChangeEditorState(const WebKit::EditorState& editorState)
{
    WebKit::EditorState clientEditorState = editorState;
    WKEditorStateEventType eventType = None;

    if ((m_editorState.isContentEditable != clientEditorState.isContentEditable) && !clientEditorState.shouldIgnoreSelectionChanges) {
        if (clientEditorState.isContentEditable)
            eventType = ShouldImeOpen;
        else
            eventType = ShouldImeClose;
    } else if (m_editorState.isContentEditable && clientEditorState.isContentEditable && !clientEditorState.shouldIgnoreSelectionChanges) {
        bool isOnlyMovedOrResized = !clientEditorState.isFocusMoved
            && ((m_editorState.fieldLang == clientEditorState.fieldLang)
            && (m_editorState.fieldRect != clientEditorState.fieldRect)
            && (m_editorState.fieldType == clientEditorState.fieldType)
            && (m_editorState.hasPreviousNode == clientEditorState.hasPreviousNode)
            && (m_editorState.hasNextNode == clientEditorState.hasNextNode)
            && (m_editorState.psOSKAttr == clientEditorState.psOSKAttr));

        if (isOnlyMovedOrResized)
            eventType = ShouldImeUpdatePositionRect;
        else if ((m_editorState.fieldLang != clientEditorState.fieldLang)
            || (m_editorState.fieldRect != clientEditorState.fieldRect)
            || (m_editorState.fieldType != clientEditorState.fieldType)
            || (m_editorState.hasPreviousNode != clientEditorState.hasPreviousNode)
            || (m_editorState.hasNextNode != clientEditorState.hasNextNode)
            || (m_editorState.psOSKAttr != clientEditorState.psOSKAttr))
            eventType = ShouldImeReopen;
    }

    if (m_client && (eventType != None))
        m_client->didChangeEditorState(*this, eventType, clientEditorState);

    if (m_client && (clientEditorState.caretOffset != -1)
        && ((clientEditorState.fieldText != m_editorState.fieldText)
            || (clientEditorState.caretOffset != m_editorState.caretOffset)
            || (clientEditorState.hasComposition != m_editorState.hasComposition)))
        m_client->didChangeEditorState(*this, ShouldImeUpdateContext, clientEditorState);

    if (!clientEditorState.selectionIsRange && clientEditorState.hasComposition)
        didChangeCompositionState(clientEditorState.compositionRect);

    if (clientEditorState.selectionIsRange && !clientEditorState.shouldIgnoreSelectionChanges)
        didChangeSelectionState(clientEditorState.selectedText, clientEditorState.selectedRect);
    else if (m_editorState.selectionIsRange && !m_editorState.shouldIgnoreSelectionChanges && !clientEditorState.selectionIsRange)
        didChangeSelectionState(""_s, WebCore::IntRect());

    m_editorState = clientEditorState;
}

void PlayStationWebView::didChangeSelectionState(const String& selectedText, const WebCore::IntRect& selectedRect)
{
    if (m_client)
        m_client->didChangeSelectionState(*this, selectedText, selectedRect);
}

void PlayStationWebView::didChangeCompositionState(const WebCore::IntRect& compositionRect)
{
    if (m_client)
        m_client->didChangeCompositionState(*this, compositionRect);
}

#if ENABLE(PUNCH_HOLE)
void PlayStationWebView::getPunchHoles(WKPunchHole* holes, int arrayLengthOfHoles, int* numberOfCopiedPunchHoles, int* numberOfActualPunchHoles)
{
    if (auto* drawingArea = static_cast<DrawingAreaProxyCoordinatedGraphics*>(m_page->drawingArea())) {
        *numberOfCopiedPunchHoles = 0;
        *numberOfActualPunchHoles = drawingArea->punchHoles().size();
        for (const auto& hole : drawingArea->punchHoles()) {
            if (*numberOfCopiedPunchHoles >= arrayLengthOfHoles)
                break;

            WKPunchHole* h = &holes[*numberOfCopiedPunchHoles];

            h->quad[0][0] = hole.data().quad.p1().x();
            h->quad[0][1] = hole.data().quad.p1().y();

            h->quad[1][0] = hole.data().quad.p2().x();
            h->quad[1][1] = hole.data().quad.p2().y();

            h->quad[2][0] = hole.data().quad.p3().x();
            h->quad[2][1] = hole.data().quad.p3().y();

            h->quad[3][0] = hole.data().quad.p4().x();
            h->quad[3][1] = hole.data().quad.p4().y();

            h->opacity = hole.data().opacity;
            h->canvasHandle = hole.data().canvasHandle;
            h->flags = hole.data().flags;

            (*numberOfCopiedPunchHoles)++;
        }
    } else {
        *numberOfCopiedPunchHoles = 0;
        *numberOfActualPunchHoles = 0;
    }
}
#endif

void PlayStationWebView::setUsesOffscreenRendering(bool enabled)
{
    m_usesOffscreenRendering = enabled;
}

bool PlayStationWebView::usesOffscreenRendering() const
{
    return m_usesOffscreenRendering;
}

} // namespace WebKit
